## 线性dp:

### 最长上升子序列

    dp[i]:以ai结尾的最长上升子序列长度
	dp[1]=1:边界值
	dp[i]=max{1,dp[j]+1}{ai>aj,j<i}:转移方程

### 最长有效括号

    dp[i]:以i开始(包含元素i)到结尾的最长有效括号表达式长度，初始全置为0
	for(i=len-2;i>=0;i--)
	{
	if(i+1+dp[i+1]号元素存在&&i+1+dp[i+1]号元素为")"&&i号元素为"("){
		dp[i]=dp[i+1]+2;
		if(1+i+dp[i+1]i+1号元素存在){
		   dp[i]+=dp[i+1+dp[i+1]+1]
			}
		}

    }

### 最长公共子序列

### 鸡蛋掉落

```c++
//K个鸡蛋，有1到N层的楼层,存在楼层F,>F的楼层将鸡蛋扔下都会碎，<=F的楼层将鸡蛋扔下都不会碎，求至少需要的次数(即最坏情况下的次数)
	//状态表示
	dp[n][m]: n个鸡蛋，m层楼，确定F的至少需要的次数
	//状态转移
	dp[i][j]=min{res,max{dp[i-1][floor-1],dp[i][j-floor]}+1}(floor:1-->N)
```

### 编辑距离

版本一：

```c++
//给定两个字符串A,B 可进行如下操作
//delete:删除A中任意一个字符
//insert:在A的任意某个位置插入任意字符
//change:将A的任意一个字符替换掉
  
  //状态表示
  dp[i][j]:A的开头到i号和B的开头到j号的编辑距离(使用上述操作将A转换成B的最小次数)
  //转移方程
  dp[i][j]=dp[i-1][j-1] (ai=bj)
  dp[i][j]=min{dp[i-1][j-1],dp[i-1][j],dp[i][j-1]}+1
  //边界值
  dp[i][0]=i;
  dp[0][j]=j;
```

### 通配符匹配

```c++
//"?"和"*": 前面匹配一个特定字符,后者匹配字符串(可以为空串和单个字符):主串s、模式串p
    //状态表示
	dp[i][j]:s前i个是否能和p的前j个匹配初始化为全false
    //状态转移
        dp[i][j]=dp[i-1][j-1] (si==pj or pj=='?' )
        dp[i][j]=dp[i][j-1]||dp[i-1][j] (pj=='*')
   //边界值
 	dp[0][0]=true
	dp[0][i]=dp[0][i-1] (pi=='*')

```

## 区间dp:

### 最长回文子串

### 判断是否是扰乱字符串

## 背包dp:

### 组合总和

### 01背包

### 完全背包

## 树形dp:

### 二叉树中最大路径和

### 二叉树的直径

### vertib算法

## 状态压缩dp:

## 数位dp

### 数字为1的个数

## 计数型dp:

### 无障碍物版不同路径dp

### 障碍物版不同路径dp

## 递推型dp

## 记忆化搜索:

## 斜率dp:

## 单调队列dp:

(空处再挑一易一难二题即可)
